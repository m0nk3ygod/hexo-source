---
title: "🔒 Computer Architecture (Dreamhack)"
date: 2025-08-13
categories: [Dreamhack, Basic]
tags: [dreamhack, basic, computer architecture, isa, register, segment, flag, pointer]
password: "tjwjddltoddlf"
abstract: "이 글은 보호되어있습니다."
message: "비밀번호를 입력하세요."
---

<br>

### 들어가기 앞서...

컴퓨터 과학을 왜 배워야 할까?

해킹은 <U>응용 학문</U>이다.  
응용 학문 : 어떤 기반이 되는 학문이 있고, 이를 응용하여 나아가는 학문

해킹의 뿌리가 되는 기반 학문이 바로 **컴퓨터 과학**이다.

따라서 숙련된 해커가 되기 위해선 단순히 알려진 기술을 습득하는 것에 그치지 않고 바탕이 되는 컴퓨터 과학을 이해하기 위해 노력해야 한다.

이제 이를 자세히 공부해보자.

<br>

# Computer Science

컴퓨터는 각자 다른 기능을 수행하는 여러 부품들의 도움으로 작동한다.

- CPU : 컴퓨터의 작동에 핵심이 되는 연산을 처리함.  
- 저장장치 : 데이터를 저장함.  
- GPU : 그래픽 데이터를 처리함.  
- 랜카드 : 네트워크 통신을 처리함.  
- 사운드 카드 : 소리 데이터를 처리함.  

이런 식으로 각 부품들은 특징이 뚜력하여, 컴퓨터에서 고유의 기능을 수행한다.

이처럼 서로 다른 부품들이 모여서 '컴퓨터'라는 하나의 기계로서 작동할 수 있는 것은 컴퓨터에 대한 기본 설계가 존재하기 때문이다. 이 설계에 맞춰서 여러 하드웨어가 개발되고, 이들을 조립해서 컴퓨터가 완성된다.

#### 컴퓨터 과학에서는 이러한 설계를 **'컴퓨터 구조(Computer Architecture)'** 라고 부른다.

전체적인 컴퓨터 구조 중에서 특히 CPU가 사용하는 명령어와 관련된 설계를  
**명령어 집합구조(Instruction Set Architecture, ISA)** 라고 하는데,  
가장 널리 사용되는 ISA 중 하나가 **x86-64 아키텍처**이다.

<br>

# Computer Architecture

**컴퓨터 구조(Computer Architecture)** 란 CPU, 메모리, 입출력 장치와 같은 하드웨어 구성 요소가  
<U>어떻게 설계되고 상호작용하는지를</U> 연구하는 학문을 말한다.

즉, 프로그램이 실제로 **어떤 과정을 거쳐** 기계 수준에서 실행되는지에 대한 **큰 그림** 을 다루는 분야이다.

- 컴퓨터의 기능 구조에 대한 설계  
- 명령어 집합구조 (ISA)  
- 마이크로 아키텍처  
- 하드웨어 및 컴퓨팅 방법에 대한 설계

<U>'컴퓨터의 기능 구조에 대한 설계'</U>란  
컴퓨터가 연산을 효율적으로 하기 위해 어떤 기능들이 컴퓨터에 필요한지 고민하고, 설계하는 분야이다.

대표적으로 **폰 노이만 구조**가 있다.

<U>'CPU의 명령어에 대한 설계'</U>는
**명령어 집합구조(Instruction Set Architecture, ISA)** 라고 불리며,  
CPU가 이해하고 실행할 수 있는 <U>명령어 집합</U>과  
해당 명령어들의 동작 방식을 정의한 규약을 말한다.

대표적으로 **ARM, MIPS, AVR, Intel x86 및 x86-64** 등이 있다.

<U>CPU의 하드웨어적 설계</U>는  
**마이크로 아키텍처(Micro Architecture)** 라고 불리며,  
CPU가 명령어 집합 구조(ISA)를 어떻게 효율적으로 구현하고 실행할지 CPU의 회로를 설계하는 분야이다.

- 파이프라인(Pipline) : 명령어를 순서대로 병렬 처리  
- 캐시(Cache) : 자주 사용하는 데이터를 임시로 보관  
(**성능과 전력 소모** 에 영향을 미치는 부분들)

<br>

## 폰 노이만 구조(Von Neumann Architecture)

초기 컴퓨터 과학자 중 한명인 폰 노이만(Von Neumann)은  
컴퓨터에 <U>연산, 제어, 저장</U>의 세가지 핵심 기능이 필요하다고 생각했다.

근대의 컴퓨터는 연산과 제어를 위해 **중앙처리장치(Central Processing Unit, CPU)** 를,  
저장을 위해 **기억장치(Memory)** 를 사용한다.

그리고 장치간에 데이터나 제어 신호를 교환할 수 있도록 **버스(Bus)** 라는 전자 통로를 사용한다.

![dreamhack cs figure1](/assets/img/dreamhack/2025-08-13-15-56-34.png)  
(출처 : Dreamahack - "Background: Computer Architecture 강의 중")

<br>

### 중앙처리 장치 (Central Processing Unit, CPU)

**CPU는 프로그램의 연산을 처리하고 시스템을 관리하는 컴퓨터의 두뇌** 이다.

- 산술 논리 장치 (Arithmetic Logic Unit, ALU) : 산술/논리 연산을 처리함
- 제어장치 (Control Unit) : CPU를 제어함
- 레지스터 (Register) : CPU에 필요한 데이터를 저장함

<br>

### 기억장치 (Memory)

**기억장치는 컴퓨터가 동작하는데 필요한 여러 데이터를 저장하기 위해 사용** 된다.

용도에 따라 <U>주기억장치</U>와 <U>보조기억장치</U>로 분류된다.

- 주기억장치 : 프로그램 실행과정에서 필요한 데이터들을 임시로 저장하기 위해 사용  
(대표적으로 **램(Random-Access Memory, RAM)** 이 있음)  
- 보조기억장치 : 운영체제, 프로그램 등과 같은 데이터를 장기간 보관하고자 할 때 사용  
(대표적으로 **하드 드라이브(Hard Disk Drive, HDD), SSD(Solid State Drive)** 가 있다.)

<br>

### 버스 (Bus)

**버스는 컴퓨터 부품가 부품 사이 또는 컴퓨터와 컴퓨터 사이에 신호를 전송하는 통로** 를 말한다.

- 데이터 버스 (Data Bus) : 데이터가 이동  
- 주소 버스 (Address Bus) : 주소를 지정  
- 제어 버스 (Control Bus) : 읽기/쓰기를 제어  

이 외에도 랜선이나 데이터 전송 소프트웨어, 프로토콜 등도 버스라고 불린다.

<details>
<summary>기억장치가 있는데 CPU안에 레지스터가 왜 필요할까?</summary>
<div markdown="1">

메모리는 용량이 크지만 속도가 느리고, 
 CPU가 명령을 처리할 때마다 메모리에서 직접 읽어오면 전체 처리 속도가 크게 떨어진다.

그래서 CPU 안에 레지스터라는 아주 작은 용량의 초고속 기억장치를 두고, 연산에 필요한 데이터를 미리 올려놓고 바로바로 처리하는 것이다.

- 메모리 = 창고 안
- 레지스터 = 작업대 위

</div>
</details>

<br>

## 명령어 집합 구조 (Instruction Set Architecture, ISA)

명령어 집합 구조(Instruction Set Architecture, ISA)란 **CPU가 해석하는 명령어의 집합을 의미** 한다.

프로그램은 기계어로 이루어져있다.  
프로그램을 실행하면 이 기계어로된 명령어들을 CPU가 읽고, 처리한다.  
ISA는 기계어를 CPU가 어떻게 해석하고 처리할지 방법을 정의한다.

(IA-32, x86-64 (x64), MIPS, AVR 등 다양하게 존재)

ISA는 크게 2가지 종류로 나눌 수 있다.

- CISC (Complex Instruction Set Architecture)
- RISC (Reduced Instruction Set Architecture)

<br>

### CISC (Complex Instruction Set Architecture)

1970년대에 나온 명령어 집합 구조로, 그 당시에는 메모리가 비싸고 용량이 적었기에 메모리 효율성에 초점을 맞춰 개발된 구조이다. 그렇기 때문에 한정된 메모리에 고밀도의 명령어를 담을 수 있어 메모리 낭비를 줄일 수 있다. 하지만 시간이 지나면서 기술이 발전함에 따라 사용할 수 있는 메모리 옹량은 늘어나고, CISC 구조의 단점이 드러나게 되어 새로운 구조를 만들게 되었다.

x86-64 아키텍처가 해당 명령어 집합 구조를 사용한다.

<br>

### RISC (Reduced Instruction Set Architecture)

1980년대에 나온 명령어 집합 구조로, CISC 구조의 몇 가지 단점을 해결하기 위해 개발되었다. 명령어의 길이가 적고 짧으며, 고정된 길이의 명령어만 사용한다. 명령어의 길이가 일정하기 때문에 CPU가 빠르게 디코딩할 수 있고, 전력 효율이 좋기 때문에 저전력 기기에 적합하다. 대신 명령어 개수가 적기 때문에 코드 크기가 커질 수 있고, 어셈블리 프로그래밍이 CISC에 비해 상대적으로 복잡할 수 있다. 

모바일 기기, 임베디드에 주로 사용되며 ARM, MIPS 아키첵처가 해당 명령어 집합 구조를 사용한다.  
(저전력 기기에 적합)

<br>

### x86-64 아키텍처

**x86-64** 는 x86 아키텍처와 호환되는 64비트 아키텍처이다.

Inter64, IA-32e, amd64, EM64T...

여러가지 이름으로 불린다.

<br>

#### n 비트 아키텍처

'**64** 비트 아키텍처', '**32** 비트 아키텍처'에서  
**64** 와 **32** 는 <U>CPU가 한번에 처리할 수 있는 데이터의 크기</U>를 말한다.

컴퓨터 과학에서는 이를 CPU가 이해할 수 있는 데이터의 단위라는 의미에서 
##### "WORD"
라고 부른다.

<U>CPU가 한번에 처리할 수 있는 데이터의 크기</U> 라는 것은 다음 뜻과 같다.

**1. 레지스터 크기**  
 CPU 내부의 아주 빠른 임시 저장 공간인 레지스터가 한 번에 저장할 수 있는 데이터의 양  
**2. ALU 연산 데이터 크기**  
 CPU 안에 있는 ALU (Arithmetic Logic Unit)에서 연산할 수 있는 데이터의 크기  
**3. 표현 가능한 주소의 크기(데이터의 크기)**  
 메모리 상의 데이터를 가리키기 위해 사용할 수 있는 주소 범위, 즉 한 번에 접근할 수 있는 메모리 크기를 결정  
**4. 버스(Bus)의 대역폭**  
 CPU와 메모리, 또는 다른 부품들 사이에서 한 번에 전송할 수 있는 데이터의 양

> <주의>  
> 어셈블리어를 공부할 때에도 WORD 라는 표현을 볼 수 있는데,  
> 이때의 WORD는 16bit 부호 없는 정수를 다룰 때 사용하는 자료형이다.  
>  
> 초창기 CPU 아키텍처는 16비트를 사용했는데,  
> 이때 CPU로 한 번에 처리할 수 있는 데이터의 크기가 16비트였다...  
> 이런 역사적인 이유로 x86-64 어셈블리어에서는 여전히 WORD 자료형을 16비트로 이해하는 것이 맞다.

<br>

### x86-64 아키텍처: 레지스터

레지스터는 CPU가 데이터를 빠르게 저장하고 사용할 떄 이용하는 보관소이며,  
산술 연산에 필요한 데이터를 저장하거나 주소를 저장하고 참조하는 등 다양한 용도로 사용된다.

x64 아키텍처에는 다음과 같은 레지스터가 존재한다.

- 범용 레지스터(General Register)
- 세그먼트 레지스터(Segment Register)
- 명령어 포인터 레지스터(Instruction pointer Register, IP)
- 플래그 레지스터(Flag Register)

<br>

#### 범용 레지스터 (General Register)

주로 데이터 연산을 위해 사용되는 레지스터 이다.

주 용도는 정해져있지만,  
말 그대로 <U>범용</U>이기 때문에 그 외 용도로도 사용할 수 있다.

**x86-64** 에서 범용 레지스터는 **8바이트(64bit)** 까지 저장할 수 있으므로,  
부호 없는 정수 기준으로 2^64 - 1 까지의 수를 저장할 수 있다.

다음은 범용 레지스터들의 주용도 이다.

| 레지스터 이름 | 의미                     | 주용도 |
|---------------|--------------------------|--------|
| rax           | Accumulator Register     | 함수의 반환 값 |
| rbx           | Base Register            | x64에서는 주된 용도 없음 |
| rcx           | Counter Register         | 반복문의 반복 횟수, 각종 연산의 시행 횟수 |
| rdx           | Data Register            | x64에서는 주된 용도 없음 |
| rsi           | Source Index             | 데이터를 옮길 때 원본을 가리키는 포인터 |
| rdi           | Destination Index        | 데이터를 옮길 때 목적지를 가리키는 포인터 |
| rsp           | Stack Pointer            | 사용중인 스택의 위치를 가리키는 포인터 |
| rbp           | Stack Base Pointer       | 스택의 바닥을 가리키는 포인터 |

이 외에도 x64에서는 **r8, r9, r10, r11, r12, r13, r14, 15** 라는 범용 레지스터가 추가로 존재한다.

<br>

#### 세그먼트 레지스터 (Segment Register)

세그먼트 레지스터(Segment Register)는 x86 아키텍처에서 메모리를 **세그먼트 단위로 접근** 하는 데 사용되는 특수한 레지스터이다.

과거엔 16비트 프로세서를 사용하였는데, 이 때 CPU가 직접 접근할 수 있는 주소 공간이 작았기 때문에 메모리를 효율적으로 관리하기 위해 등장했다.

과거 IA-32나 IA-16과 같은 16비트 프로세서를 사용했을 때,  
16비트 레지스터로는 접근할 수 있는 주소 공간이 작았다.  
그래서 16비트 범위 밖에 있는 주소에 접근할 때는  
어떤 주소가 `cd:offest` 이라고 한다면 `cd<<4 + offset` 으로 계산해  
16비트 범위 밖에 있는 주소까지 접근할 수 있게 된다.

예를 들어  
`cs = 0xb000`  
이고  
`offset = 0x20`  
이라면  

`cs<<4 + offset` = 0xb000*0x10 + 0x20 = `0xb0020` 이 되어, 16비트 범위 밖의 주소를 접근할 수 있게된다.

x64 아키텍처가 등장하면서, 사용가능한 메모리 주소 범위가 매우 넓어져 그 용도가 크게 바뀌었다.

- cs : 코드 영역
- ds : 데이터 영역
- ss : 스택 영역의 주소

그 외의 레지스터( **es, fs, gs** )들은 범용적인 용도로 사용한다.

이 6가지 세그먼트 레지스터의 크기는 16비트이다.

| 이름                         | 주용도                               |
|-----------------------------|--------------------------------------|
| CS (Code Segment)           | 실행할 코드의 시작 주소                 |
| DS (Data Segment)           | 프로그램에 지정된 데이터 영역의 시작 주소  |
| SS (Stack Segment)          | 스택 영역의 시작 주소                   |
| ES, FS, GS                  | 범용적인 용도로 사용                    |

<br>

#### 명령어 포인터 레지스터 (Instruction pointer Register, IP)

CPU가 어느 부분의 코드를 실행할지 가리키는 역할을 한다.

x64 아키텍처의 명령어 레지스터는 *rip* 이며, 크기는 **8바이트** 이다.

<br>

#### 플래그 레지스터 (Flag Register)

CPU가 연산을 수행한 후 결과의 상태를 저장하는 특수한 레지스터이다.

특정 연산 후 조건을 판단하는 데 사용되며,  
특히 분기 (조건문), 인터럽트 등에 활용된다.

x64 아키텍처에서는 **RFLAGS** 라고 하는 **8바이트** 크기의 플래그 레지스터가 존재하며,  
64비트를 저장할 수 있기 때문에 총 64개의 플래그를 저장할 수 있다.

깃발을 <U>올리고</U>, <U>내리는</U> 행위로 신호를 전달하듯, 플래그 레지스터는 자신을 구성하는 여러 비트들로 CPU의 현재 상태를 표현한다.

![dreamhack cs figure2](/assets/img/dreamhack/2025-08-13-17-02-38.png)  
(출처 : Dreamhack - "Background: Computer Architecture 플래그 레지스터 강의 중")

RFLAGS는 64비트이므로 최대 64개의 플래그를 사용할 수 있지만,  
실제로는 위 그림의 20여개의 비트만 사용한다.

그리고 자주 사용되는 것들은 다음 표와 같다.

| 플래그 | 의미 |
|--------|------|
| CF (Carry Flag)     | 부호 없는 수의 연산 결과가 비트의 범위를 넘을 경우 설정 됩니다. |
| ZF (Zero Flag)      | 연산의 결과가 0일 경우 설정 됩니다. |
| SF (Sign Flag)      | 연산의 결과가 음수일 경우 설정 됩니다. |
| OF (Overflow Flag)  | 부호 있는 수의 연산 결과가 비트 범위를 넘을 경우 설정 됩니다. |

해당 표의 플래그들은 **상태 플래그(Status Flag)** 로,  
연산을 수행한 뒤 결과의 상태를 저장하는데 사용한다.

ex) `a  = 3`, `b = 5` 라고 했을 때  
`a - b` 연산을 하면 결과는 "음수" -> `SF` 가 설정됨  
**CPU는 SF를 통해 a가 b보다 작았음을 알 수 있다.**

<br>

### 레지스터 호환

x86-64 아키텍처는 x86과 호환 가능하다.

x86 아키텍처인 IA-32 레지스터는 모두 **32비트** 크기를 가지며,  
eax, ebx, ecx, edx, edi, esi, ebp, esp 등 접두어로 **e** 가 붙은 이름을 가지고 있다.

x86-64는 32비트 레지스터가 확장된 형태로,  
rax, rbx, rcx, rdx, rdi, rsi, rbp, rsp 등 접두어로 **r** 이 붙는다는 특징을 가지고 있다.

eax의 경우 rax의 하위 32비트를 의미한다.

마찬가지로 16비트 아키텍처인 IA-16 또한 16비트 크기를 가지고, IA-32도 IA-16과의 호환을 위해  
ax, bx, cx, dx, di, si, bp, sp가 eax, ebx, ecx, edx, edi, esi, ebp, esp 의 하위 16비트를 의미한다.

여기서 또 일부 레지스터는 다시 상위 8비트, 하위 8비트로 나눌 수 있는데  
예시로는 ax의 경우 ah, al 로 나뉘고,
ah는 상위 8비트  
al은 하위 8비트를 의미한다.

이를 아래 그림을 통해 쉽게 이해할 수 있다.

![dreamhack cs figure3](/assets/img/dreamhack/2025-08-13-17-13-52.png)
(출처 : Dreamhack - "Background: Computer Architecture 레지스터 호환 강의 중")