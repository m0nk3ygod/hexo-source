---
title: "🔒 GDB (Dreamhack)"
date: 2025-08-13
categories: [Dreamhack, Pwnable]
tags: [dreamhack, pwnable, tools, gdb, linux]
password: "tjwjddltoddlf"
abstract: "이 글은 보호되어있습니다."
message: "비밀번호를 입력하세요."
---

<br>

### 들어가기에 앞서...

프로그램을 개발 할 때는 일반적으로 코드의 논리 구조를 신중하게 설계하고, 코드를 작성해 나가게된다.  
그런데 개발 초기에 아무리 신중하게 설계해도, 코드의 규모가 커지다 보면 실수가 발생하기 마련이다...  

이렇게 실수로 발생한 프로그램의 결함을 **버그(Bug)** 라고 한다.

개발자들은 농담처럼 개발에 투자한 시간만큼 버그를 잡는 데 사용한다고 말한다. (ㅋ)  
그 정도로 작성된 코드에서 버그를 없애는 것은 어렵다.

그래서 이런 어려움을 해소하고자 **디버거(Debugger)** 가 개발되었다.

이번에는 리눅스의 대표적인 디버거 중 하나인 **GDB (GNU Debugger)** 를 다뤄보자. 

<br>

# GDB & GDB plugin Install (환경 세팅)

우선 해당 명령어를 통해 GDB 를 설치해주자.

```bash
sudo apt-get install gdb
```

이제 디버깅에 도움이 되는 플러그인들을 설치해보자.  

여러가지 플러그인이 많지만, 바이너리 분석 용도로 널리 사용되는 플러그인들은 다음과 같다.

- gef : https://github.com/hugsy/gef
- peda : https://github.com/longld/peda
- pwngdb : https://github.com/scwuaptx/Pwngdb
- pwndbg : https://github.com/pwndbg/pwndbg

여기서 **pwndbg** 를 설치해보자.

해당 명령을 통해 설치를 바로 진행할 수 있다.

```bash
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh
```

`git` 이 설치 되지 않았다면 git을 먼저 설치해야 한다.

```bash
sudo apt-get install git
```

이후 다시 pwndbg를 설치해주자.

GDB 설치를 마쳤다면 `gdb`를 입력해 GDB를 실행시켜본다.  
`pwndbg>` 라고 나오면 설치에 성공한 것이다!!

```bash
monkey@Fire-Monkey:/mnt/d/picoCTF/binary ex/PIE Time$ gdb
GNU gdb (Ubuntu 15.0.50.20240403-0ubuntu1) 15.0.50.20240403-git
Copyright (C) 2024 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word".
pwndbg: loaded 188 pwndbg commands and 46 shell commands. Type pwndbg [--shell | --all] [filter] for a list.
pwndbg: created $rebase, $base, $hex2ptr, $argv, $envp, $argc, $environ, $bn_sym, $bn_var, $bn_eval, $ida GDB functions (can be used with print/break)
------- tip of the day (disable with set show-tips off) -------
Use track-got enable|info|query to track GOT accesses - useful for hijacking control flow via writable GOT/PLT
pwndbg>
```

<br>

# 실습 해보기 (예제)

해당 소스 코드를 작성하고 주석에 맞게 설정해준다.

(또는 [여기](https://dreamhack-lecture.s3.amazonaws.com/uploads/reversing/debugee)를 클릭해서 소스 파일을 다운 받아주자.)

같은 코드를 컴파일 해도 다른 바이너리가 나올 수 있다.  
(gcc 버전이 다양하기 때문에 환경에 따라 컴파일된 바이너리의 어셈블리 언어나 주소가 달라질 수 있음)

```c
// gcc -o debugee debugee.c -no-pie
#include <stdio.h>
int add(int a, int b) {
    return a + b;
}
int main() {
    int a = 2;
    int b= 3;
    printf("%d + %d = %d\n", a, b, add(a, b));
    return 0;
}
```

<br>

# GDB 기초 사용 방법

<br>

## 파일 불러오기 

### `file`

`gdb` 명령을 입력하여 GDB 를 실행하고 나서 가장 먼저 해야 할 일은  
<U>바이너리를 GDB에 불러오는 것</U>이다.

GDB를 실행해서 나온 프롬프트에 `file [binary]`를 입력해 바이너리를 불러올 수 있다.  

(`gdb ./debugee` 와 같이 `gdb`를 실행할 때 인자로 바이너리 경로를 넣어줘도 됨.)

```bash
pwndbg> file debugee
Reading symbols from debugee...

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Debuginfod has been disabled.
To make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.
(No debugging symbols found in debugee)
pwndbg>
```

성공적으로 수행했다면 위 문구가 나오게 된다.

이제 여러 디버깅 명령을 이용하여 디버깅을 수행하면 된다.

> 이미 실행 중인 프로세스를 GDB로 디버깅하려면?
> `gdb -p <PID>` 로 `-p` 옵션과 프로세스 ID 를 이용해서 실행 중인 프로세스를 디버깅을 할 수 있다.

<br>

## 실행 흐름 제어하기

### `run`

GDB에서 프로그램을 실행시키는 명령은 `run`이다.

`r`만 입력해도 `run`과 동일하게 실행되게 된다.  
(이런 단축어가 많으니 알아두면 좋다)

```bash
pwndbg> run <프로그램 인자>
```

인자가 필요없는 프로그램의 경우 `run`만 입력해도 된다.

<br>

### `break` & `continue`

`break` 명령은 특정 주소에 **중단점(Breakpoint)** 을 설정하는 기능이고, 
`continue` 명령은 중단된 프로그램을 계속 실행 시키는 기능이다.

각각 `b`, `c` 처럼 단축어로도 사용 가능하다.

```bash
pwndbg> b main
Breakpoint 1 at 0x401156
# 또는
pwndbg> b *0x401156
Breakpoint 1 at 0x401156
```

함수 이름으로 중단점을 걸 때는 상관 없지만,  
주소에 직접 중단점을 설정할 때는 `*` 를 붙여야한다.

`run`을 통해 실행시켜보면, 

```bash
pwndbg> run
[중략]
────────────────────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]─────────────────────────────────────────────────────────────────────────────
 ► 0x401156 <main+8>     sub    rsp, 0x10                    RSP => 0x7fffffffdb60 (0x7fffffffdb70 - 0x10)
   0x40115a <main+12>    mov    dword ptr [rbp - 8], 2       [0x7fffffffdb68] <= 2
   0x401161 <main+19>    mov    dword ptr [rbp - 4], 3       [0x7fffffffdb6c] <= 3
   0x401168 <main+26>    mov    edx, dword ptr [rbp - 4]     EDX, [0x7fffffffdb6c] => 3
   0x40116b <main+29>    mov    eax, dword ptr [rbp - 8]     EAX, [0x7fffffffdb68] => 2
   0x40116e <main+32>    mov    esi, edx                     ESI => 3
   0x401170 <main+34>    mov    edi, eax                     EDI => 2
   0x401172 <main+36>    call   add                         <add>

   0x401177 <main+41>    mov    ecx, eax
   0x401179 <main+43>    mov    edx, dword ptr [rbp - 4]
   0x40117c <main+46>    mov    eax, dword ptr [rbp - 8]
────────────────────────────────────────────────────────────────────────────────────────[중략]
pwndbg>
```

복잡하고 많은 정보가 출력 될텐데 그건 뒤에서 자세히 알아보자...

위 정보들은 `context` 명령을 통해서도 확인할 수 있다.

또는 프로그램이 다음과 같이 중단점에 도달했을 때 자동으로 `context` 명령이 실행된다.

중단 이후 필요한 작업을 모두 수행했다면,  
`c` 또는 `continue` 명령을 통해 다시 실행을 이어나갈 수 있다.

```bash
pwndbg> continue
Continuing.
2 + 3 = 5
[Inferior 1 (process 3775) exited normally]
pwndbg>
```

> 중단점을 여러번 건너 뛰고 싶다면?
> `continue <숫자>` 또는 `c <숫자>` 를 이용하면 중단점을 여러 번 건너뛸 수 있다.

<br>

### `entry` & `start`

리눅스는 실행파일 형식으로 [ELF (Executable and Linkable Format)](https://en.wikipedia.org/wiki/Executable)를 규정하고 있다.

ELF는 크게 **헤더** 와 **여러 섹션들** 로 구성되어 있다.  

헤더에는 실행에 필요한 여러 정보가,  
섹션들에는 컴파일된 기계어 코드, 프로그램 문자열을 비롯한 여러 데이터가 포함되어 있다.

ELF의 헤더 중에 **진입점(Entry Point, EP)** 라는 필드가 있는데,  
운영체제는 ELf를 실행할 때, 집입점의 명령어부터 프로그램을 실행한다.

`readelf` 명령어를 통해 EP를 확인할 수 있는데, *debugee* 의 진입점은 `0x401050` 이다.

> `readelf`는 ELF 파일을 분석하기 위한 도구로, 진입점 정보와 함께 ELF 파일의 다양한 정보를 분석하여 제공한다. (-h 는 헤더 정보를 보는 옵션)

```bash
monkey@Fire-Monkey:~/Systemhacking/GDBPractice$ readelf -h debugee
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x401050
  Start of program headers:          64 (bytes into file)
  Start of section headers:          13912 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         31
  Section header string table index: 30
```

`entry` 명령어는 집입점부터 프로그램을 분석할 수 있게 해주는 명령이다.

`entry` 명령어를 실행시키면 진입점(0x401050)에 중단점이 설정되어 실행이 되게 된다.



```bash
pwndbg> entry

Program stopped.
0x00007ffff7fe4540 in _start () from /lib64/ld-linux-x86-64.so.2
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
───────────────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]────────────────────────────────────────────────────────────────────
 RAX  0x38
 RBX  0
 RCX  0x7fffffffdca8 —▸ 0x7fffffffdf69 ◂— 'SHELL=/bin/bash'
 RDX  0x7ffff7fca380 (_dl_fini) ◂— endbr64
 RDI  0x7ffff7ffe2e0 ◂— 0
 RSI  0x7ffff7ffe8b8 ◂— 0
 R8   0x7fffffffdf3a ◂— '/home/monkey/Systemhacking/GDBPractice/debugee'
 R9   0x7ffff7ffb440 (tunable_list) ◂— 'glibc.malloc.mxfast'
 R10  0x7fffffffd890 ◂— 0x800000
 R11  0x203
 R12  0x401050 (_start) ◂— endbr64
 R13  0x7fffffffdc90 ◂— 1
 R14  0
 R15  0
 RBP  0
 RSP  0x7fffffffdc90 ◂— 1
 RIP  0x401050 (_start) ◂— endbr64
[중략]
```

결과적으로 `rip` 레지스터가 진입점(0x401050)를 가리키게 되고,  
진입점부터 실행해볼 수 있게 된다.

이와 비슷한 명령으로 `start` 명령이 있다.

`start` 명령어는 EP가 아닌 `main()`부터 분석할 수 있는 명령어이다.

`start` 명령도 `entry` 명령과 동작 원리는 동일하다.

<br>

## 실행 흐름 추적하기

### `ni` (next instruction) & `si` (step into)

중단점에 도달했을 때 명령어를 한 줄 씩 자세히 분석해야하는데,  
이때 `ni` 또는 `si` 명령어를 쓰면 된다.

둘다 어셈블리 명령어를 한 줄 실행한다는 공통점이 있다. 

하지만,  
`ni` 명령은 함수 내부로 들어가지 않고,  
`si` 명령은 함수 내부로 들어간다는 차이점이 있다.

(궁금하면 breakpoint 걸고 ni, si 했을 때 rip 차이를 보면 됨)

### `finish`

`si`(step into)로 함수 내부에 들어가서 필요한 부분을 모두 분석햇는데, 함수의 규모가 커서 원래 흐름으로 돌아가기 어려울 수 있다.

이럴 때는 `finish` 명령어를 사용하여 함수의 끝까지 한 번에 실행할 수 있다.

<br>

# 디버깅을 위해 자주 사용하는 명령어들

<br>

## `info` / `i`

<br>

### `info registers` / `i r`

`info` 명령어는 뜻 그대로 <U>정보를 보여주는 명령어</U>이다.

다음은 `main()`에 중단점을 설정한 뒤 실행한 후  
중단점에 도달했을 때 `info registers` 명령어를 수행한 결과이다.

```bash
pwndbg> i r
rax            0x40114e            4198734
rbx            0x7fffffffdc98      140737488346264
rcx            0x403e00            4210176
rdx            0x7fffffffdca8      140737488346280
rsi            0x7fffffffdc98      140737488346264
rdi            0x1                 1
rbp            0x7fffffffdb70      0x7fffffffdb70
rsp            0x7fffffffdb70      0x7fffffffdb70
r8             0x0                 0
r9             0x7ffff7fca380      140737353917312
r10            0x7fffffffd890      140737488345232
r11            0x203               515
r12            0x1                 1
r13            0x0                 0
r14            0x403e00            4210176
r15            0x7ffff7ffd000      140737354125312
rip            0x401156            0x401156 <main+8>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
fs_base        0x7ffff7d9d740      140737351636800
gs_base        0x0                 0
```

`info registers` 명령어는 레지스터의 값을 확인하고 싶을 때 사용된다.

이런 상황 외에 레지스터에 들어 있는 값을 바로 사용하고 싶은 경우,  
`$<레지스터명>` 형식으로 바로 사용할 수 있다.

예를 들어 `rdi` 레지스터가 가지고 있는 값이 특정 코드의 주소이고, 해당 주소에 중단점을 걸고 싶을 때는 다음과 같은 명령어를 써볼 수 있다.

```bash
pwndbg> b $rdi
```

<br>

### `info breakpoints` / `i b`

`info breakpoints` 명령어는 프로그램의 실행 여부와 상관 없이 사용할 수 있는 명령어이다.

이 명령어도 뜻에서 볼 수 있듯 `break` 명령어로 설정한 중단점들을 확인할 수 있다.

다음은 `main()`과 `printf()`에 중단점을 설정하고 `info breakpoints`를 수행한 결과이다.

```bash
pwndbg> i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000401156 <main+8>
        breakpoint already hit 1 time
2       breakpoint     keep y   0x00007ffff7e00100 in __printf at ./stdio-common/printf.c:28
```

결과를 보면 각 중단점마다 번호가 부여된 것을 알 수 있고,  
이 번호를 이용하여 특정 중단점을 비활성화 및 활성화 또는 삭제할 수 있다.

- `enable <중단점 번호>` : 해당 중단점 활성화
- `disable <중단점 번호>` : 해당 중단점 비활성화
- `delete <중단점 번호>` : 해당 중단점 삭제 (`d` 단축어로 대체 가능)

```bash
pwndbg> d 1
```

<br>

## `disassemble` / `disass`

GDB는 기계어를 **디스어셈블(Disassemble)** 하는 기능을 기본적으로 탑재하고 있다.

추가로, 플러그인으로 설치한 pwndbg에는 디스어셈블된 결과를 가독성 좋게 출력해주는 기능이 있다.

`disassemble` (또는 `disass`)는 GDB가 기본적으로 제공하는 디스어셈블 명령어이다.  
해당 명령에 인자로 함수 이름을 전달하면 <U>해당 함수가 반환될 때 까지 전부 디스어셈블</U> 하여 보여준다.

```bash
pwndbg> disass main
Dump of assembler code for function main:
   0x000000000040114e <+0>:     endbr64
   0x0000000000401152 <+4>:     push   rbp
   0x0000000000401153 <+5>:     mov    rbp,rsp
   0x0000000000401156 <+8>:     sub    rsp,0x10
   0x000000000040115a <+12>:    mov    DWORD PTR [rbp-0x8],0x2
   0x0000000000401161 <+19>:    mov    DWORD PTR [rbp-0x4],0x3
   0x0000000000401168 <+26>:    mov    edx,DWORD PTR [rbp-0x4]
   0x000000000040116b <+29>:    mov    eax,DWORD PTR [rbp-0x8]
   0x000000000040116e <+32>:    mov    esi,edx
   0x0000000000401170 <+34>:    mov    edi,eax
   0x0000000000401172 <+36>:    call   0x401136 <add>
   0x0000000000401177 <+41>:    mov    ecx,eax
   0x0000000000401179 <+43>:    mov    edx,DWORD PTR [rbp-0x4]
   0x000000000040117c <+46>:    mov    eax,DWORD PTR [rbp-0x8]
   0x000000000040117f <+49>:    mov    esi,eax
   0x0000000000401181 <+51>:    lea    rax,[rip+0xe7c]        # 0x402004
   0x0000000000401188 <+58>:    mov    rdi,rax
   0x000000000040118b <+61>:    mov    eax,0x0
   0x0000000000401190 <+66>:    call   0x401040 <printf@plt>
   0x0000000000401195 <+71>:    mov    eax,0x0
   0x000000000040119a <+76>:    leave
   0x000000000040119b <+77>:    ret
End of assembler dump.
```

**pwndbg** 에서 제공하는 디스어셈블 명령어로는 `u`, `nearpc`, `pdisass` 가 있다.

디스어셈블된 코드를 가독성 좋게 출력해준다.

```bash
pwndbg> u
 ► 0x401156 <main+8>     sub    rsp, 0x10                    RSP => 0x7fffffffdb70 - 0x10
   0x40115a <main+12>    mov    dword ptr [rbp - 8], 2
   0x401161 <main+19>    mov    dword ptr [rbp - 4], 3
   0x401168 <main+26>    mov    edx, dword ptr [rbp - 4]
   0x40116b <main+29>    mov    eax, dword ptr [rbp - 8]
   0x40116e <main+32>    mov    esi, edx
   0x401170 <main+34>    mov    edi, eax
   0x401172 <main+36>    call   add                         <add>

   0x401177 <main+41>    mov    ecx, eax
   0x401179 <main+43>    mov    edx, dword ptr [rbp - 4]
   0x40117c <main+46>    mov    eax, dword ptr [rbp - 8]
pwndbg> nearpc
 ► 0x401156 <main+8>     sub    rsp, 0x10                    RSP => 0x7fffffffdb70 - 0x10
   0x40115a <main+12>    mov    dword ptr [rbp - 8], 2
   0x401161 <main+19>    mov    dword ptr [rbp - 4], 3
   0x401168 <main+26>    mov    edx, dword ptr [rbp - 4]
   0x40116b <main+29>    mov    eax, dword ptr [rbp - 8]
   0x40116e <main+32>    mov    esi, edx
   0x401170 <main+34>    mov    edi, eax
   0x401172 <main+36>    call   add                         <add>

   0x401177 <main+41>    mov    ecx, eax
   0x401179 <main+43>    mov    edx, dword ptr [rbp - 4]
   0x40117c <main+46>    mov    eax, dword ptr [rbp - 8]
```

(근데 실행중에만 작동하는 듯?)

<br>

## `x` (eXamine)

프로그램을 분석하다 보면 가상 메모리에 존재하는 임의주소의 값을 관찰해야 할 때가 있다.

이때 사용하는게 `x` 명령어이다.

`x`를 이용하면  
<U>특정 주소</U>에서 <U>원하는 길이만큼</U>의 데이터를 <U>원하는 형식으로 인코딩</U>하여 볼 수 있다.

| 포멧 | 크기 |
|------|------|
| `x` : 16진수 | `b` : byte, 1 byte |
| `o` : 8진수 | `h` : halfword, 2 byte |
| `d` : 10진수 | `w` : word, 4 byte |
| `u` : 부호 없는 10진수 | `g` : giant, 8 byte |
| `t` : 2진수 | |
| `f` : float형 | |
| `a` : 주소 | |
| `i` : 명령어 | |
| `c` : 문자 | |
| `s` : 문자열 | |

위 표를 참고해서 원하는 포맷과 크기를 조합해  
`x/<포멧 및 크기>` 형태의 명령어를 사용할 수 있다.

값 여러개를 한 번에 보기를 원하면  
`x/<개수><포멧 및 크기>` 형태의 명령어를 사용하면 된다.

예시로 확인해보자.

1. `rsp` 부터 80바이트를 8바이트씩 Hex 형식으로 10개 출력
```bash
pwndbg> x/10gx $rsp
0x7fffffffdb70: 0x00007fffffffdc10      0x00007ffff7dca1ca
0x7fffffffdb80: 0x00007fffffffdbc0      0x00007fffffffdc98
0x7fffffffdb90: 0x0000000100400040      0x000000000040114e
0x7fffffffdba0: 0x00007fffffffdc98      0xbc3bc7597450a484
0x7fffffffdbb0: 0x0000000000000001      0x0000000000000000
```

2. `rip` 부터 5줄의 어셈블리 명령어 출력
```bash
pwndbg> x/5i $rip
=> 0x401156 <main+8>:   sub    rsp,0x10
   0x40115a <main+12>:  mov    DWORD PTR [rbp-0x8],0x2
   0x401161 <main+19>:  mov    DWORD PTR [rbp-0x4],0x3
   0x401168 <main+26>:  mov    edx,DWORD PTR [rbp-0x4]
   0x40116b <main+29>:  mov    eax,DWORD PTR [rbp-0x8]
```

3. 특정 주소의 문자열 출력
```bash
pwndbg> x/s 0x400000
0x400000:       "\177ELF\002\001\001" 
```

<br>

> [참고]  
> 가상 메모리는 프로그램이 실행되기 전에는 할당되지 않으므로   
> `x` 명령어는 프로그램 실행 도중에만 사용할 수 있다.

<br>

## `telescope`

`telescope`는 pwndbg가 제공하는 강력한 메모리 덤프 기능이다.

특정 주소의 메모리 값들을 보여주는 것에서 그치지 않고,  
메모리가 참조하고 있는 주소를 재귀적으로 탐색하여 값을 보여준다.

> [ 추가 설명 ]  
> 지정한 주소부터 일정 길이만큼 메모리를 연속적으로 출력하면서, 각 값이 포인터라면 그 포인터가 가리키는 데이터까지 해석해서 보여준다.

```bash
pwndbg> tele $rsp
00:0000│ rbp rsp 0x7fffffffdb70 —▸ 0x7fffffffdc10 —▸ 0x7fffffffdc70 ◂— 0
01:0008│+008     0x7fffffffdb78 —▸ 0x7ffff7dca1ca (__libc_start_call_main+122) ◂— mov edi, eax
02:0010│+010     0x7fffffffdb80 —▸ 0x7fffffffdbc0 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x401100 (__do_global_dtors_aux) ◂— endbr64
03:0018│+018     0x7fffffffdb88 —▸ 0x7fffffffdc98 —▸ 0x7fffffffdf3a ◂— '/home/monkey/Systemhacking/GDBPractice/debugee'
04:0020│+020     0x7fffffffdb90 ◂— 0x100400040 /* '@' */
05:0028│+028     0x7fffffffdb98 —▸ 0x40114e (main) ◂— endbr64
06:0030│+030     0x7fffffffdba0 —▸ 0x7fffffffdc98 —▸ 0x7fffffffdf3a ◂— '/home/monkey/Systemhacking/GDBPractice/debugee'
07:0038│+038     0x7fffffffdba8 ◂— 0xbc3bc7597450a484
```

(함수 호출 직후, 스택에 어떤 값이 쌓였는지 한눈에 확인 가능)

<br>

## `vmmap`

`vmmap`은 가상 메모리의 레이아웃을 보여준다.

어떤 파일이 매핑 된 영역일 경우, 해당 파일의 경로까지 보여준다.

(이 명령어는 프로그램이 실행된 상태에서 이용할 수 있다. 실행 전까지는 가상메모리에 없기 때문!)

```bash
pwndbg> vmmap
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
             Start                End Perm     Size Offset File (set vmmap-prefer-relpaths on)
          0x400000           0x401000 r--p     1000      0 debugee
          0x401000           0x402000 r-xp     1000   1000 debugee
          0x402000           0x403000 r--p     1000   2000 debugee
          0x403000           0x404000 r--p     1000   2000 debugee
          0x404000           0x405000 rw-p     1000   3000 debugee
    0x7ffff7d9d000     0x7ffff7da0000 rw-p     3000      0 [anon_7ffff7d9d]
    0x7ffff7da0000     0x7ffff7dc8000 r--p    28000      0 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7dc8000     0x7ffff7f50000 r-xp   188000  28000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f50000     0x7ffff7f9f000 r--p    4f000 1b0000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f9f000     0x7ffff7fa3000 r--p     4000 1fe000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7fa3000     0x7ffff7fa5000 rw-p     2000 202000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7fa5000     0x7ffff7fb2000 rw-p     d000      0 [anon_7ffff7fa5]
    0x7ffff7fbd000     0x7ffff7fbf000 rw-p     2000      0 [anon_7ffff7fbd]
    0x7ffff7fbf000     0x7ffff7fc3000 r--p     4000      0 [vvar]
    0x7ffff7fc3000     0x7ffff7fc5000 r-xp     2000      0 [vdso]
    0x7ffff7fc5000     0x7ffff7fc6000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7fc6000     0x7ffff7ff1000 r-xp    2b000   1000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7ff1000     0x7ffff7ffb000 r--p     a000  2c000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7ffb000     0x7ffff7ffd000 r--p     2000  36000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7ffd000     0x7ffff7fff000 rw-p     2000  38000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffffffdd000     0x7ffffffff000 rw-p    22000      0 [stack]
```

> **파일 매핑이란?** 
>   
> 어떤 파일을 메모리에 적재하는 것을 파일 매핑이라고 한다. 위 메모리 레이아웃에서 /home/dreamhack/debuggee와 /usr/lib/x86_64-linux-gnu/libc.so.6, /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2가 매핑된 파일들이다.  
>  
> 리눅스에서는 ELF를 실행할 때, 먼저 ELF의 코드와 여러 데이터를 가상 메모리에 매핑하고, 해당 ELF에 링크된 공유 오브젝트(Shared Object, so) 들을 추가로 메모리에 매핑한. 공유 오브젝트는 윈도우의 DLL과 대응되는 개념으로, 자주 사용하는 함수들을 미리 컴파일해둔 것이다. C 언어의 printf(), scanf() 등이 리눅스에서는 Libc (Library C)에 구현되어 있다. 공유 오브젝트에 이미 구현된 함수를 호출할 때는 매핑된 메모리에 존재하는 함수를 대신 호출한다.

<br>

## `backtrace` / `bt`

**콜 스택(Call Stack)**이란 프로그램이 실행되는 동안 함수가 호출되는 순서를 저장하는 구조이다.

프로그램이 실행되면서 하나의 함수가 다른 함수를 호출할 때마다 새로운 함수 호출 정보가 추가되며,  
함수 실행이 끝나면 최근에 호출된 함수부터 순차적으로 제거된다.

콜 스택은 디버깅할 때 유용한 정보로 사용될 수 있다. 

만약 어떤 함수에 전달된 <U>인자</U>에 문제가 발생해 버그가 발생했다면,  
이 <U>인자</U>가 어떤 함수로부터 왔는지 거슬러 올라가면서 버그의 원인을 찾아야 하는데,   

이 때 콜 스택이 유용하게 사용될 수 있다.

GDB 에서는 `backtrace` 또는 `bt` 명령어를 이용해 콜 스택을 확인할 수 있다.

다음은 `add()`를 호출한 뒤 콜스택을 `bt` 명령어를 통해 확인하는 예시이다.

```bash
pwndbg> b add
Breakpoint 1 at 0x40113e
pwndbg> r
(중략)
pwndbg> bt
#0  0x000000000040113e in add ()
#1  0x0000000000401177 in main ()
#2  0x00007ffff7dca1ca in __libc_start_call_main (main=main@entry=0x40114e <main>, argc=argc@entry=1, argv=argv@entry=0x7fffffffdc98) at ../sysdeps/nptl/libc_start_call_main.h:58
#3  0x00007ffff7dca28b in __libc_start_main_impl (main=0x40114e <main>, argc=1, argv=0x7fffffffdc98, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>,
    stack_end=0x7fffffffdc88) at ../csu/libc-start.c:360
#4  0x0000000000401075 in _start ()
pwndbg>
```

<br>

## `dump memory`

프로세스의 메모리 상태를 파일로 저장할 때 사용하는 명령어이다.

다음과 같은 형식으로 사용할 수 있다.

```bash
dump memory <파일명> <시작주소> <끝주소>
```

예를 들어, 프로그램의 코드 영역을 덤프 뜨고 싶다면 아래와 같이 수행하면 된다.

```bash
pwndbg> entry
(중략)
pwndbg> vmmap
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
             Start                End Perm     Size Offset File (set vmmap-prefer-relpaths on)
          0x400000           0x401000 r--p     1000      0 debugee
          0x401000           0x402000 r-xp     1000   1000 debugee
          0x402000           0x403000 r--p     1000   2000 debugee
          0x403000           0x404000 r--p     1000   2000 debugee
          0x404000           0x405000 rw-p     1000   3000 debugee
    0x7ffff7d9d000     0x7ffff7da0000 rw-p     3000      0 [anon_7ffff7d9d]
    0x7ffff7da0000     0x7ffff7dc8000 r--p    28000      0 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7dc8000     0x7ffff7f50000 r-xp   188000  28000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f50000     0x7ffff7f9f000 r--p    4f000 1b0000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f9f000     0x7ffff7fa3000 r--p     4000 1fe000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7fa3000     0x7ffff7fa5000 rw-p     2000 202000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7fa5000     0x7ffff7fb2000 rw-p     d000      0 [anon_7ffff7fa5]
    0x7ffff7fbd000     0x7ffff7fbf000 rw-p     2000      0 [anon_7ffff7fbd]
    0x7ffff7fbf000     0x7ffff7fc3000 r--p     4000      0 [vvar]
    0x7ffff7fc3000     0x7ffff7fc5000 r-xp     2000      0 [vdso]
    0x7ffff7fc5000     0x7ffff7fc6000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7fc6000     0x7ffff7ff1000 r-xp    2b000   1000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7ff1000     0x7ffff7ffb000 r--p     a000  2c000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7ffb000     0x7ffff7ffd000 r--p     2000  36000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7ffd000     0x7ffff7fff000 rw-p     2000  38000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffffffdd000     0x7ffffffff000 rw-p    22000      0 [stack]
pwndbg> dump memory code_section 0x401000 0x402000
pwndbg> exit
monkey@Fire-Monkey:~/Systemhacking/GDBPractice$ ls
code_section  debugee  debugee.c
```

`entry` 명령어로 프로그램을 실행한 뒤,  
`vmmap` 명령어로 프로그램의 코드 영역의 시작 주소와 끝 주소를 얻는다.  
이후 `dump memory` 명령으로 덤프를 수행한다.

> **어디가 코드 영역이지...?**  
> 코드 영역은 기본적으로 읽기 권한과 실행 권한이 부여되어 있다.  
> 그래서 `vmmap`의 출력에서 debugee 파일이 매핑된 영역 중 읽기 권한과 실행 권한이 부여된 영역이 debugg 바이너리의 코드 영역이 된다.

<br>

## `context` / `ctx`

pwndbg는 주요 메모리들의 상태를 프로그램이 실행되고 있는 **맥락(Context)**라고 부르며,  
이를 가독성 있게 표현할 수 있는 인터페이스를 갖추고 있다.

기본적으로 프로그램이 실행되다가 중단점에 도달하면 자동으로 실행되지만,  
별도로 `context` 또는 `ctx` 명령어를 통해 실행할 수도 있다.

`context`는 크게 4개의 영역으로 구분된다.

1. `REGISTERS` : 레지스터의 상태를 보여준다.
2. `DISASM` : `rip`부터 여러 줄에 걸쳐 디스어셈블된 결과를 보여준다.
3. `STACK` : `rsp`부터 여러 줄에 걸쳐 스택의 값들을 보여준다.
4. `BACKTRACE` : 현재 `rip`에 도달할 때까지 어떤 함수들이 중첩되어 호출됐는지 보여준다.

```bash
pwndbg> entry

Program stopped.
0x00007ffff7fe4540 in _start () from /lib64/ld-linux-x86-64.so.2
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
───────────────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]────────────────────────────────────────────────────────────────────
 RAX  0x38
 RBX  0
 RCX  0x7fffffffdca8 —▸ 0x7fffffffdf69 ◂— 'SHELL=/bin/bash'
 RDX  0x7ffff7fca380 (_dl_fini) ◂— endbr64
 RDI  0x7ffff7ffe2e0 ◂— 0
 RSI  0x7ffff7ffe8b8 ◂— 0
 R8   0x7fffffffdf3a ◂— '/home/monkey/Systemhacking/GDBPractice/debugee'
 R9   0x7ffff7ffb440 (tunable_list) ◂— 'glibc.malloc.mxfast'
 R10  0x7fffffffd890 ◂— 0x800000
 R11  0x203
 R12  0x401050 (_start) ◂— endbr64
 R13  0x7fffffffdc90 ◂— 1
 R14  0
 R15  0
 RBP  0
 RSP  0x7fffffffdc90 ◂— 1
 RIP  0x401050 (_start) ◂— endbr64
────────────────────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]─────────────────────────────────────────────────────────────────────────────
 ► 0x401050 <_start>       endbr64
   0x401054 <_start+4>     xor    ebp, ebp                    EBP => 0
   0x401056 <_start+6>     mov    r9, rdx                     R9 => 0x7ffff7fca380 (_dl_fini) ◂— endbr64
   0x401059 <_start+9>     pop    rsi                         RSI => 1
   0x40105a <_start+10>    mov    rdx, rsp                    RDX => 0x7fffffffdc98 —▸ 0x7fffffffdf3a ◂— 0x6f6d2f656d6f682f ('/home/mo')
   0x40105d <_start+13>    and    rsp, 0xfffffffffffffff0     RSP => 0x7fffffffdc90 (0x7fffffffdc98 & -0x10)
   0x401061 <_start+17>    push   rax
   0x401062 <_start+18>    push   rsp
   0x401063 <_start+19>    xor    r8d, r8d                    R8D => 0
   0x401066 <_start+22>    xor    ecx, ecx                    ECX => 0
   0x401068 <_start+24>    mov    rdi, main                   RDI => 0x40114e (main) ◂— endbr64
──────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────
00:0000│ r13 rsp 0x7fffffffdc90 ◂— 1
01:0008│         0x7fffffffdc98 —▸ 0x7fffffffdf3a ◂— '/home/monkey/Systemhacking/GDBPractice/debugee'
02:0010│         0x7fffffffdca0 ◂— 0
03:0018│ rcx     0x7fffffffdca8 —▸ 0x7fffffffdf69 ◂— 'SHELL=/bin/bash'
04:0020│         0x7fffffffdcb0 —▸ 0x7fffffffdf79 ◂— 'NVM_RC_VERSION='
05:0028│         0x7fffffffdcb8 —▸ 0x7fffffffdf89 ◂— 'WSL2_GUI_APPS_ENABLED=1'
06:0030│         0x7fffffffdcc0 —▸ 0x7fffffffdfa1 ◂— 'WSL_DISTRO_NAME=Ubuntu'
07:0038│         0x7fffffffdcc8 —▸ 0x7fffffffdfb8 ◂— 'WT_SESSION=6208d62d-226d-4c85-a73b-613637a0e872'
────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────
 ► 0         0x401050 _start
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg>
```

이들은 어셈블리를 실행할 때마다 갱신되어 방금 실행한 어셈블리 명령어가 메모리에 어떤 영향을 줬는지 쉽게 파악할 수 있게 돕는다.

<br>

## `set`

`set` 명령어는 <U>프로세스의 메모리 상태를 변경할 수 있는 명령어</U>이다.

주로 레지스터 값을 변경하거나 특정 주소의 메모리 값을 변경하기 위해 사용한다.

(실행 중인 상태에서만 동작함!)

```bash
set <주소/레지스터> = <변경할 값>
```

위와 같이 사용할 수 있다. 예시를 통해 확인해보자.

```bash
pwndbg> set $rax = 0
pwndbg> set $rsp = $rbp
```

이렇게 값을 변경해주고, `info registers` (또는 `i r`) 를 통해 확인해보면

```bash
pwndbg> i r
rax            0x38                56
rbx            0x0                 0
rcx            0x7fffffffdca8      140737488346280
rdx            0x7ffff7fca380      140737353917312
rsi            0x7ffff7ffe8b8      140737354131640
rdi            0x7ffff7ffe2e0      140737354130144
rbp            0x0                 0x0
rsp            0x7fffffffdc90      0x7fffffffdc90
```
(변경전)

```bash
pwndbg> set $rax = 0
pwndbg> set $rsp = $rbp
pwndbg> i r
rax            0x0                 0
rbx            0x0                 0
rcx            0x7fffffffdca8      140737488346280
rdx            0x7ffff7fca380      140737353917312
rsi            0x7ffff7ffe8b8      140737354131640
rdi            0x7ffff7ffe2e0      140737354130144
rbp            0x0                 0x0
rsp            0x0                 0x0
```
(변경후)

특정 주소의 값을 바꾸기 위해서는 자료형이 필요하다.

GDB는 자료형을 통해 해당 주소의 메모리 값을 어떻게 바꿀지 결정하고,  
C언어 스타일의 자료형을 지원한다.

해당 예시를 보자.

```bash
pwndbg> set *(unsigned int*)0x400000 = 10
pwndbg> set *(float*)0x400010 = 3.14
```

첫 번째는 메모리 주소**0x400000**을 `unsigned int *` 형으로 역참조한 후,  
여기에 정수 10을 저장한다.

따라서 0x400000 주소부터 시작하여 **4바이트의 메모리 공간**에 10을 기록  
(예, 리틀 엔디안 시스템에서는 `0x0A 00 00 00`)하게 된다.

두 번째 메모리 주소 **0x400010**을 `float *`형으로 역참조한 후,  
여기에 부동소수점 값 3.14를 저장한다.

따라서 0x400010 주소부터 시작하여 **4바이트의 메모리 공간**에 3.14가  
IEEE 754 표준에 맞는 부동소수점 표현으로 저장된다.

이후 `x`(eXamine) 명령을 통해 메모리 값을 확인할 수 있다.

```bash
pwndbg> x/wu 0x400000
0x400000:       10
pwndbg> x/wf 0x400010
0x400010:       3.1400001
```

~~GDB 끝~~