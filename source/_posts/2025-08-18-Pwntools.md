---
title: "🔒 Pwntools (Dreamhack)"
date: 2025-08-19
categories: ["< Dreamhack >", Study, "- Tools"]
tags: [dreamhack, pwnable, tools, pnwtools, python]
password: "tjwjddltoddlf"
abstract: "이 글은 보호되어있습니다."
message: "비밀번호를 입력하세요."
---

<br>

# Pwntools 설치

```bash
sudo apt-get update
sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential
python3 -m pip install --upgrade pip
python3 -m pip install --upgrade pwntools
```

이후 `python3`를 실행시키고, 아래 명령을 수행해서 잘 설치되었는지 확인해보자.

```python
$ python3
Python 3.10.6 (main, Mar 10 2023, 10:55:28) [GCC 11.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from pwn import *
>>>
```

명령을 수행했을 때 오류가 뜬다면, 제대로 설치되지 않은 것이다.

<br>

### pip 정상 설치가 안될 경우

```bash
error: externally-managed-environment

× This environment is externally managed
╰─> To install Python packages system-wide, try apt install
    python3-xyz, where xyz is the package you are trying to
    install.

    If you wish to install a non-Debian-packaged Python package,
    create a virtual environment using python3 -m venv path/to/venv.
    Then use path/to/venv/bin/python and path/to/venv/bin/pip. Make
    sure you have python3-full installed.

    If you wish to install a non-Debian packaged Python application,
    it may be easiest to use pipx install xyz, which will manage a
    virtual environment for you. Make sure you have pipx installed.

    See /usr/share/doc/python3.12/README.venv for more information.

note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.
hint: See PEP 668 for the detailed specification.
```

Ubuntu 24.04, Python 3.12 버전부터 파이썬 패키지를 관리하는 정책이 바뀌어 파이썬 패키지를 설치할 때 위와 같은 오류가 뜰 수 있다.

기본적으로 Debina/Ubuntu에서 설치된 Python 환경은 시스템에서 직접 관리한다.  
이 상태에서 시스템의 Python 환경에 pip install 명령어를 쓰면 환경이 깨질 수 있어 위험하므로, 이를 막기 위해 해당 에러 메세지를 출력하는 것이다.

이를 해결하기 위해서는 파이썬 가상 환경인 venv 위에 패키지를 설치하거나  
pip install 명령어를 사용할 때 `--break-system-packages` 를 넣어 사용해야 한다.  
(기본적으로 권장되는 방법은 파이썬 가상 환경 venv를 활용하는 것임.)

ex. `pip install pwntools --break-system-packages`

<br>

# pwntools 프로세스 통신 기능

<br>

## 연결을 맺는 함수

<br>

### `process()`

`process()`는 로컬에 위치한 프로그램을 실행하고 이와 통신하기 위해 사용하는 함수이다.

해당 함수 인자로 통신할 프로그램의 경로를 전달하면,  
전달된 프로그램이 실행된 뒤 해당 프로그램과 연결을 맺어준다.

다음은 `./example` 프로그램을 실행하는 예시이다.

```python
form pwn import *
p = process("./example")
```

위 명령이 잘 수행되어 연결에 성공하면,  
해당 함수는 이후 데이터를 송수신하는데 사용될 `pwnlib.tubes` 클래스를 반환하고  
해당 클래스는 `p`에 저장된다.

프로그램을 실행할 때 **인자** 넣어주거나 **환경 변수** 를 설정할 경우 다음과 같이 작성하면 된다.

```python
form pwn import *
p = process([]"./example", "AAAA"], env={"LD_PRELOAD":./libc.so.6"})
```

(`argv[1]`에 "AAAA"를 전달하고, `LD_PRELOAD` 환경 변수를 `./libc.so.6`으로 설정하는 코드)

<br>

### `remote()`

`remote()`는 호스트의 도메인 혹은 IP 주소와 포트 번호를 인자로 받아  
원격 서버에 통신할 때 사용되는 함수이다.

해당 함수도 연결에 성공하면 `pwnlib.tubes` 클래스를 반환한다.

다음은 `example.com` 호스트의 `1337`번 포트에 연결하는 코드이다.

```python
from pwn import *
r = remote("example.com", 1337)
```

기본적으로 `TCP` 연결을 맺게 되는데,  
`UDP` 연결을 맺고 싶다면 다음 코드처럼 작성하면 된다.

```python
from pwn import *
r = remote("example.com", 1337, typ='udp')
```

<br>

### `ssh()`

`ssh()`는 SSH 서버에 접속하여 통신하기 위해 사용하는 함수이다. 

아래 코드는 `127.0.0.1` 호스트의 `22`번 포트에 열린 SSH 서버에 `dreamhack`이라는 사용자 이름과 `dreamhack`이라는 비밀번호로 로그인하여 접속하는 코드이다.

```python
fomr pwn import *
s = ssh("dreamhack", "127.0.0.1", port=22, password="dreamhack")
```

<br>

## 데이터 송수신 함수

여기서 사용되는 함수들은 수신한 데이터를 **bytes** 클래스로 반환한다.

> **\[ 이유? \]**  
> 네트워크/프로세스의 I/O는 **"문자"** 가 아니라 **"바이트(8-bits)"** 로만 통신하기 때문이다.

이 점을 꼭 참고하자.

<br>

### `recv()`

`recv()`는 데이터를 수신하기 위해 사용한다. 

해당 함수의 변형들이 존재하는데, 자주 사용하는 것들은 다음과 같다.

```python
from pwn import *
p = process('./example')

data = p.recv(1024)
data = p.recvline()
data = p.recvn(5)
data = p.recvuntil(b'hello')
data = p.recvall()
```

- `data = p.recv(1024)` :  출력 데이터를 최대 1024바이트까지 받아서 data에 저장  
- `data = p.recvline()` :  출력 데이터를 개행문자를 만날 때까지 받아서 data에 저장  
- `data = p.recvn(5)` :  출력 데이터를 "정확히" 5바이트만 받아서 data에 저장 ( **recv()와 다른 점** )  
- `data = p.recvuntil(b'hello')` :  b'hello'(바이트열로 변환한 hello)를 출력할 때까지 데이터를 수신하여 data에 저장  
- `data = p.recvall()` :  출력 데이터를 프로세스가 종료될 때까지 받아서 data에 저장  

<br>

### `send()`

`send()`는 데이터를 전송하기 위해 사용한다.

해당 함수도 변형들이 존재하는데, 자주 사용하는 것들은 다음과 같다.

```python
from pwn import*
p = process('./example')

p.send(b'A')
p.sendline(b'A')
p.sendafter(b'hello', b'A')
p.sendlineafter(b'hello', b'A')
```

- `p.send(b'A')` :  ./example에 b'A'를 입력  
- `p.sendline(b'A')` :  ./example에 b'A' + b'\n'을 입력 (줄바꿈까지 입력)  
- `p.sendafter(b'hello', b'A')` :  ./example이 b'hello'를 출력하면, b'A'를 입력  
- `p.sendlineafter(b'hello', b'A')` :  ./example이 b'hello'를 출력하면, b'A' + b'\n'을 입력  

`sendafter()`와 `sendafterline()`의 경우, 실제 인자로 전달된 내용들이 나올 때 까지 수신한 뒤 데이터를 전송한다.

<br>

### `interactive()`

`interactive()`는 터미널에서 사용자가 실시간으로 데이터를 수신하고 전송할 있게 하는 함수이다.

이 함수를 호출하면 터미널을 통해 프로세스에 입력 값을 전달할 수 있게 되고  
프로세스의 출력도 실시간으로 터미널에 표시되어  
마치 터미널에서 프로그램을 실행시켜 조작하는 것과 비슷한 효과를 준다.

해당 함수도 `pwnlib.tubes` 클래스에 구현된 함수이기에, 다음과 같이 코드를 작성해볼 수 있다.

```python
from pwn import *
p = process("./example")
p.interactive()
```

보통 쉘 권한을 얻어내 쉘을 열었을 경우 입출력을 쉽게 하기 위해 사용되며,  
`interactive()`가 호출된 상태에서 연결을 종료하고 싶다면 터미널에 `Ctrl+D`를 입력해 종료할 수 있다.

`interactive()` 함수가 종료될 때는 프로세스와의 연결을 끊어 통신을 종료한다.

<br>

## 연결을 종료하는 함수

<br>

### `close()`

`close()` 함수는 내가 원할 때 연결을 종료시킬 수 있는 함수이며,  
마찬가지로 `pwnlib.tubes` 클래스에 구현된 함수이기에, 다음과 같이 코드를 작성해볼 수 있다.

```python
from pwn import *
p = process("./example")
p.close()
```

이때 `close()` 함수를 사용하려면 해당 함수가 실행되는 순간에 연결이 유지되고 있어야 한다.

연결이 종료되면 `pwnlib.tubes` 클래스인 `p` 객체 내부의 자원이 정리되기 때문에,  
`pwnlib.tubes` 클래스에 정의된 함수들은 사용할 수 없다.

(`inetractive()`는 함수가 종료될 때 자동으로 연결이 끊기기 때문에, `close()`를 쓸 필요가 없다.)

<br>

## 로그 출력

<br>

### `context.log_level`

pwntolls로 통신할 시, 송수신 기록들을 확인하고 싶을 수 있다.

이때 `context.log_level`을 이용해 로그 출력의 상세도를 설정할 수 있다.

예를 들어 송수신 데이터를 모두 보고 싶을 경우 `context.log_level`을 `'debug'`로 설정한다.

```python
from pwn import *
context.log_level='debug'

p = process("./example")
p.recvall()
```

<br>

`debug`를 비롯해 `context.log_level`로 설정할 수 있는 로그 상세도는 다음과 같다.

| 로그 레벨            | 출력 내용                                    |
|----------------------|---------------------------------------------|
| `critical`           | 🔥 치명적인 오류 외에 출력하지 않음           |
| `error`              | ❌ 에러 메시지만 출력                        |
| `warning` / `warn`   | ⚠️ 경고 메시지 출력                          |
| `info`               | ℹ️ 일반적인 상태 메시지 출력                  |
| `debug`              | 🐞 송수신 데이터, 내부 변수 등 상세히 출력    |

`context.log_level`을 따로 설정하지 않으면 `info`로 설정된다.

<br>

# pwntools 편리한 기능들

<br>

## Packing & Unpacking

프로그래밍에서 **패킹(Packing)** 과 **언패킹(Unpacking)** 은  
데이터를 하나의 형태로 모아 포장하거나, 다시 분해하는 것을 의미한다.

데이터를 묶고 분해한다는 맥락 안에서 패킹과 언패킹은 다양한 의미로 사용된다.

예를 들어 파이썬의 `struct` 모듈에서는 <U>데이터를 원하는 포멧대로 변환하고 변환된 값을 원래대로 되돌리는 함수의 이름으로써 `pack()`과 `unpack()`이 사용</U>되고,

<U>실행 파일을 압축하거나 압축된 실행 파일을 되돌리는 것을 패킹과 언패킹</U>이라고 표현한다.

시스템 해킹에서는 **정수 값을 bytes 클래스로 변환하거나 그 반대의 행위** 가 자주 요구되기에  
pwntools에서는 이 기능이 함수로 구현되어 있고, 이를 패킹과 언패킹이라고 표현한다.

<br>

### `p8()`, `p16()`, `p32()`, `p64()`

`p8()`, `p16()`, `p32()`, `p64()` 는 숫자를 bytes 클래스로 **패킹** 하는 함수이다.

<br>

### `u8()`, `u16()`, `u32()`, `u64()`

`u8()`, `u16()`, `u32()`, `u64()` 는 숫자를 bytes 클래스로 **언패킹** 하는 함수이다.

패킹, 언패킹 함수 뒤에 붙은 숫자는 패킹 혹은 언패킹을 수행할 때 **bytes 클래스의 비트 수** 를 의미한다.

- 패킹 : 정수 형태 -> 바이트열 (주로 데이터 전송 시 사용함)  
- 언패킹 : 바이트열 -> 정수 형태 (주로 데이터 수신 후 사람이 쓰기 좋은 정수로 해석하기 위해 사용함)

```python
from pwn import *

s8 = 0x41
s16 = 0x4142
s32 = 0x41424344
s64 = 0x4142434445464748

print(p8(s8))
print(p16(s16))
print(p32(s32))
print(p64(s64))

s8 = b"A"
s16 = b"AB"
s32 = b"ABCD"
s64 = b"ABCDEFGH"

print(hex(u8(s8)))
print(hex(u16(s16)))
print(hex(u32(s32)))
print(hex(u64(s64)))
```

```bash
b'A'
b'BA'
b'DCBA'
b'HGFEDCBA'
0x41
0x4241
0x44434241
0x4847464544434241
```

패킹 및 언패킹 함수는 기본적으로 **리틀 엔디언** 으로 동작한다.

**빅 엔디언** 으로 사용하려면 다음과 같이 작성해주면 된다.

```python
p32(0x12345678, endian='big')
```

<br>

## GDB

pwntools에는 GDB와 관련된 기능들도 있다.

<br>

### attach

`gdb.attach()`의 인자로 `process()`로 생성한 객체를 넣으면  
해당 프로세스에 GDB가 붙어 실행이 중단되고, GDB 터미널이 열려 디버깅을 수행할 수 있는 상태가 된다.

`gdb.attach()`의 인자로 `process()`로 생성한 객체 이외에  
`remote()`로 생성한 객체나 프로세스의 PID를 전달해도 된다.

하지만 `remote()`로 생성한 객체를 전달할 경우, `remote()`로 접속한 프로세스가 같은 장치에서 실행되고 있어 디버깅이 가능한 프로세스인 경우만 허용한다.

다음은 attach() 예시이다.

```python
from pwn import *
p = process("./example")
gdb.attach(p)
sleep(1)
```

`sleep(1)`을 사용한 이유는, `gdb.attach(p)` 이후 GDB가 성공적으로 붙을 수 있는 시간을 벌어주기 위함이다.

`sleep()` 대신 `pause()`를 사용하기도 한다.

<br>

## Assemble & Disassemble

- Assemble : 어셈블리 언어를 기계어로 변환  
- Disassemble : 기계어를 어셈블리 언어로 변환

<br>

### arch

어셈블과 디스어셈블은 시스템 해킹에서 자주 요구되는 기능이기에 pwntools는 이 기능을 구현하여 제공하고 있다.

먼저, **아키텍처(Instruction Set Architecture, ISA)** 마다 어셈블리 언어와 기계어가 다르기 때문에  
어셈블과 디스어셈블을 올바르게 수행하기 위해서는 대상 아키텍처를 설정해주어야 한다.

pwntools에서는 `context.arch`로 아키텍처를 설정할 수 있다.

```python
from pwn import *
context.arch = "amd64"
context.arch = "i386"
context.arch = "arm"
```

- "amd64" : x86-64  
- "i386" : x86  
- "arm" : arm

<br>

### `asm()` & `disasm()`

아키텍처를 설정하였다면, `asm()`과 `disasm()`으로 어셈블과 디스어셈블을 수행할 수 있다.

```python
from pwn import *

context.arch = "amd64" # x86-64 아키텍처로 설정

machine_code = asm('mov eax, 0')  # 어셈블리 'mov eax, 0'를 기계어로 변환
print(machine_code)
assembly_code = disasm(machine_code)  # 기계어를 어셈블리어로 변환
print(assembly_code)
```

```bash
b'\xb8\x00\x00\x00\x00'
   0:   b8 00 00 00 00          mov    eax, 0x0
```

<br>

## `ELF()`

ELF(Executable and Linkable Format)은 리눅스 운영체제의 실행 파일 형식이다.

pwntools에는 ELf 파일과 관련된 기능들을 지원한다.

`ELF()`의 인자에 ELF 파일의 경로를 넣으면 `pnwlib.elf.elf.ELF` 클래스를 반환한다.  
`pwnlib.elf.elf.ELF` 클래스에는 ELF 정보를 담고 있는 멤버 변수들과 다양한 기능을 지원하는 함수들이 구현되어 있다.

<br>

### `symbols`

`pwnlib.elf.elf.ELF` 클래스의 `symbols` 멤버 변수는 심볼들의 주소들을 가지고 있는 **doctdict 클래스** 이다.

**doctdict 클래스** 는 wpntools 내부에 구현된 클래스로,  
기존의 딕셔너리처럼 사용할 수 있으면서 **속성으로 접근** 이 가능하게 구현되어 있다.

```python
from pwn import *

e = ELF("./example")  # ELF 파일 열기
print(hex(e.symbols['write']))  # 'write' 심볼의 주소
print(hex(e.symbols.write)) # 'write' 심볼의 주소, 속성 접근
```

```bash
0x400000
0x401074
0x401074
```

> `ELF()` 와 `process()` 차이?  
>  
> `ELF()`는 실행 파일의 정보를 담는 객체일 뿐 실행을 시키진 않는다.  
> 그러나 `process()`는 실제로 실행 해서 프로세스 핸들을 반환해준다.

시스템 해킹을 수행할 때 대부분의 상황에서 **물리 주소(Physical Address)** 보다는 **가상 주소(Virtual Address)** 를 필요로 하기에  
`symbols`에서 제공하는 주소는 **가상 주소** 이다.

조금 더 정확하게 말한다면, 실행 파일에 [PIE (Position Independent Executable)](https://en.wikipedia.org/wiki/Position-independent_code) 보호 기법이 적용되어 있지 않다면 **가상 주소** 를 제공하지만,  
PIE 보호 기법이 적용되어 있다면 이미지 베이스로부터의 **상대 가상 주소(Relative Virtual Address)** 를 제공한다.

<br>

pwntools 끝