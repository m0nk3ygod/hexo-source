---
title: "🔒 Linux Memory Layout"
date: 2025-08-25
categories: ["< Dreamhack >", Windows, "- System Hacking"]
tags: [windows, kernel, usermode, kernelmode]
password: "tjwjddltoddlf"
abstract: "이 글은 보호되어있습니다."
message: "비밀번호를 입력하세요."
---

<br>

### 메모리 레이아웃(Memory Layout)

프로그램이 실행되면 프로세스가 된다.

프로세스가 실행될 때 각 프로세스는 **독립된 메모리 공간을 할당**받는다.

독립된 메모리 공간 안은 용도에 따라 여러 영역으로 나뉜다.
각 영역은 특정한 목적을 가진다. (코드로 쓰이는 목적, 데이터로 쓰이는 목적 등등)

<br>

### 메모리 영역을 나눠서 관리하면 좋은 점?

각 영역을 용도에 맞게 권한을 부여할 수 있다. (읽기 r, 쓰기 w, 실행 x)

CPU는 해당 영역에 부여된 권한의 행위만 할 수 있다.

<br>

### 세그먼트(Segment)

리눅스에서는 프로세스의 메모리를 크게 5가지 **세그먼트(Segment)** 로 구분한다.

*세그먼트* 란, **적재되는 데이터의 용도별로 메모리의 구획을 나눈 것** .

- 코드 세그먼트
- 데이터 세그먼트
- BSS 세그먼트
- 힙 세그먼트
- 스택 세그먼트
![linuxMemoryLayout figure1](/assets/img/dreamhack/b1477089dc1cee2051c2cc0da223c1a864531dee616f37867c7c96c25cde18f1.png)

<br>

### 코드 세그먼트 (Code Segment)

**프로그램의 기계어 코드가 저장**된다.
**텍스트 세그먼트(Text Segment)** 라고도 부른다.
CPU는 프로그램을 실행할 때 해당 세그먼트의 기계 코드를 메모리에 올려 실행하게 된다.

*실행 해야 함 -> 읽고 실행할 수 있는 권한이 필요!*
- **Code Segment = Read, Execute**

<U>Write 권한은 없다. </U>

왜?
쓰기 권한(Write)이 부여되어 있다면, 취약점을 이용해 해당 프로그램의 코드를 악성 코드로 수정할 수 있어 해커가 악의적인 행위를 할 수 있기 때문이다.

```C
int main() {
	printf("Hello, World!");
	return 0;
}
```

해당 코드를 컴파일 한 뒤 메인 함수를 기계 코드로 변환하면
`554889e5488d05ac0e00004889c7b800000000e8ebfeffffb8000000005dc3`
가 되는데, 
해당 기계 코드가 세그먼트에 올라가게 된다.

어셈블리어에서는`section .text:` 를 입력한 뒤 아랫줄에 어셈블리어 코드를 입력하여 컴파일 시 텍스트 세그먼트에 기계 코드가 자리 잡히게 된다

```assem
section .data
    message db "Hello, World!", 0xA
    message_len equ $ - message

section .text
    global _start

_start:
    mov rax, 1
    mov rdi, 1
    mov rsi, message
    mov rdx, message_len
    syscall

    mov rax, 60
    xor rdi, rdi
    syscall
```

<br>

### 데이터 세그먼트(Data Segment)

**컴파일 시점에 값이 정해진 전역 변수 및 전역 상수들**이 위치한다..
CPU는 이곳의 데이터를 읽을 수 있어야 한다.
- **int intialized_global = 0;**

*읽을 수 있어야 함 -> 읽기 권한이 필요!*
- **Data Segment = Read**

<U>실행 대상이 아니므로, Excute 권한은 없다.</U>

데이터 세그먼트는 또 2가지로 분류 된다.

- 쓰기가 가능한 세그먼트 **(쓰기 권한이 있다.)**
- 쓰기가 불가능한 세그먼트 **(말 그대로 쓰기 권한이 없다.)**

전역 변수가 쓰기가 가능한 세그먼트에 위치한다.  
반면 쓰기가 불가능한 세그먼트에는 프로그램이 실행되면서 <U>값이 변하면 안되는 데이터들</U>이 위치한다.

바로 전역 상수들이다.

해당 세그먼트를 **rodata(read-only data) 세그먼트**라고 부른다.

```C
int data_num = 31337;                       // data
char data_rwstr[] = "writable_data";        // data
const char data_rostr[] = "readonly_data";  // rodata
char *str_ptr = "readonly";  // str_ptr은 data, 문자열은 rodata

int main() { ... }
```

해당 소스 코드에서 주의 깊게 살펴봐야 할 변수는 `str_ptr` 이다.  
이 변수는 `"readonly"` 라는 문자열을 가리키고 있는데, 이 문자열은 <U>상수 문자열</U>로 취급되어 rodata에 위치하게 된다.  
그렇지만 `str_ptr`은 전역 변수로서 data에 위치한다.

- **str_ptr = data**
- **"readonly" = rodata**

<br>

### BSS 세그먼트 (Block Started By Symbol)

**컴파일 시점에 값이 정해지지 않은 전역 변수**가 위치하는 메모리 영역이다.  
개발자가 선언만 하고 초기화하지 않은 전역변수 등이 포함된다.

해당 세그먼트의 메모리 영역은 <U>프로그램이 시작될 때, 모두 0으로 값이 초기화</U>된다.

상수가 아니니 읽기 권한 및 쓰기 권한이 부여된다.

*변수를 자유자재로 수정 가능해야 함? -> 읽기, 쓰기 권한이 필요!*  
- **BSS Segment = Read, Write**

```C
int bss_data;

int main() {
  printf("%d\n", bss_data);  // 0
  return 0;
}
```

<br>

### 스택 세그먼트 (Stack Segment)

**프로세스의 스택이 위치하는 영역**이다.  
<U>함수의 매개변수나 지역 변수 같은 임시 변수들</U>이 실행 중에 이곳에 저장된다.

스택 내부에 변수들이 저장되므로 읽고, 쓰기가 가능해야 한다.

*CPU가 자유롭게 값을 읽고 쓸 수 있어야 함? -> 읽기, 쓰기 권한이 필요!*
- **Stack Segment = Read, Write**

해당 세그먼트는 **NX(Non-Executable)** 보호기법이 나오기 전까지 실행 권한이 존재했지만, **쉘코드(Shellcode)** 를 이용해 스택에 기계 코드를 넣어서 해커가 해당 스택 영역을 호출하는 기법이 나오면서 컴파일 시 기본적으로 NX 보호기법을 활성화 시켜 실행 권한을 없앴기 때문에 해당 세그먼트에는 읽기 권한과 쓰기 권한이 주어진다.

<br>

#### 스택 프레임(Stack Frame)

스택을 구성하는 단위를 **스택 프레임(StackFrame)** 이라고 한다.
스택 프레임은 다음 정보들을 저장한다.

- 함수가 호출될 때 전달된 <U>매개변수</U>
- 함수가 끝나고 돌아가서 돌아갈 <U>반환 주소(Return Address)</U>
- <U>지역 변수</U>

스택 프레임이 존재하는 이유?  
**각 함수가 실행을 마쳤을 때 해당 함수가 어느 함수로부터 호출 되었는지에 대한 경로와 함수의 정보를 저장하기 위해서 스택 프레임을 이용!**  
이와 동시에 함수들의 영역을 구분해주는 역할을 한다.

스택 프레임은 함수가 호출될 때 생성되고,  
반환될 때 해제된다.

하지만 프로그램의 전체 실행 흐름은 사용자의 입력을 비롯한 여러 요인에 영향을 받는다.

```c
void func() {
  int choice = 0;

  scanf("%d", &choice);

  if (choice)
    call_true();
  else
    call_false();

  return 0;
}
```
(해당 코드처럼 사용자가 `choice`에 어떤 값을 입력하는가에 따라 `call_true()`가 호출될 수도, `call_false()`가 호출될 수도 있다.)

따라서, 어떤 프로세스가 실행될 때, 이 프로세스가 얼마 만큼의 스택 프레임을 사용하게 될 지를 미리 계산하는 것은 일반적으로 불가능하다.  
그래서 운영체제는 프로세스를 시작할 때 작은 크기의 스택 세그먼트를 먼저 할당해주고, 부족해 질 때마다 이를 확장해주게 된다.

스택에 대해서 <U>'아래로 자란다'</U> 라는 표현을 종종 사용하는데,  
스택이 확장될 때, 기존 주소보다 <U>낮은 주소</U> 로 확장되기 때문이다.

**해당 코드에서는 지역변수 `choice` 가 스택에 저장되게 된다.** (매개변수)

C언어나 파이썬과 같은 고급 언어에서는 이런 스택 프레임을 직접 관리하지 않고 컴파일러에서 관리해주지만, 어셈블리어에선 함수를 호출하기 위해 직접 스택 프레임을 만들고, 함수가 끝나면 반환해주어야 한다.

<br>

### 🐵 어셈블리어 스택 프레임 관리 방법

1. **함수 프롤로그(Function Prologue)**

함수 프롤로그는 **스택 프레임을 만드는 방법** 이다.  
함수 내에서 사용할 스택과 레지스터를 준비한다.

```assem
push ebp
mov ebp, esp
sub esp, 0x100
```

- `push ebp` : 현재 베이스 포인터(ebp)를 스택에 푸쉬하여 나중에 에필로그 과정에서 복구할 수 있도록 한다.
- `mov ebp, esp` : 베이스 포인터를 현재 스택 포인터의 주소(esp, 스택의 상단)로 설정해, 베이스 포인터가 스택 상단을 가리키게 한다.
- `sub esp, 0x100` : 현재 스택 포인터의 주소로부터 일정 숫자만큼 감소시켜 함수의 지역 변수와 인자를 위한 공간을 확보한다.

2. **함수 에필로그(Function Epilogue)**

함수를 종료할 때 **스택 프레임을 정리하는 방법**이다.  
함수가 호출 되기 전 스택과 레지스터 상태로 복원한다.

```aseem
mov esp, ebp
pop ebp
ret
```

- `mov esp, ebp` : 현재 베이스 포인터(ebp)를 esp로 옮겨 현재 스택 포인터가 함수 프롤로그를 호출할 시점의 스택 포인터를 가리키게 한다.
- `pop ebp` : 푸쉬했던 베이스 포인터를 다시 팝(pop) 연산을 통해 스택에서 제거한다.
- `ret` : 함수를 호출하기 전으로 돌아간다.

ebp는 esp가 스택 바닥을 가리키게 만드는 역할이다.

참고로 `mov esp, ebp; pop ebp` 연산의 경우 x86 프로세서에서 내장 명령어가 존재하여, 다음과 같이 프로그래밍해도 동일한 에필로그를 수행한다.

```assem
leave
ret
```

<br>

### 힙 세그먼트 (Heap Segment)

**힙 데이터가 위치하는 영역**이다.  
스택과 마찬가지로 실행중에 동적으로 할당될 수 있으며, 리눅스에서는 스택 세그먼트와 반대방향으로 자란다.

`malloc()`, `calloc()` 등을 호출해서 할당받는 메모리가 해당 세그먼트에 위치하게 된다.

일반적으로 <U>읽기</U>와 <U>쓰기</U> 권한이 부여된다.
- **Heap Segment = Read, Write**

*어셈블리어에서 힙 세그먼트를 관리하고 싶다면?*  
`sys_brk()` 또는 `mmap()` 시스템 콜을 호출해 힙 세그먼트를 관리할 수 있다.  
실제로 `malloc()` 같은 함수는 내부적으로 앞서 언급한 시스템 콜을 사용하여 힙 세그먼트를 생성한다.

예제 코드를 보면

```C
int main() {
  int *heap_data_ptr =
      malloc(sizeof(*heap_data_ptr));  // 동적 할당한 힙 영역의 주소를 가리킴
  *heap_data_ptr = 31337;              // 힙 영역에 값을 씀
  printf("%d\n", *heap_data_ptr);  // 힙 영역의 값을 사용함
  return 0;
}
```

`heap_data_ptr`에 `malloc()`으로 동적 할당한 영역의 주소를 대입하고, 이 영역에 값을 쓴다.  
`heap_data_ptr`은 지역변수이므로 스택에 위치하며,  
`malloc()`으로 할당받은 힙 세그먼트의 주소를 가리킨다.

<br>

##### 힙과 스택 세그먼트가 자라는 방향이 반대인 이유?
두 세그먼트가 동일한 방향으로 자라며, 연속된 메모리 주소에 각각 할당된다고 가정해보자. 이 경우, 기존의 힙 세그먼트를 모두 사용하고 나면, 이를 확장하는 과정에서 스택 세그먼트와 충돌하게 된다.  
이를 쉽게 해결하기 위해 리눅스는 **스택을 메모리의 끝에 위치시키고, 힙과 스택을 반대로 자라게 한다**.  
이렇게 하면 힙과 스택은 메모리를 최대한 자유롭게 사용할 수 있으며, 충돌 문제로 부터도 비교적 자유롭게 된다.

